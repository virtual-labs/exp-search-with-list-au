{
  "version": 2.0,
  "questions": [
    {
      "question": "You start BFS at node A in a graph. The neighbors of A are B and C. Which node will BFS visit first?",
      "answers": {
        "a": "Node B, because it was generated first.",
        "b": "Node C, because it is alphabetically later.",
        "c": "Randomly either B or C.",
        "d": "Node with the highest degree."
      },
      "explanations": {
        "a": "Correct. BFS uses FIFO order; the first generated node is visited first.",
        "b": "Incorrect. BFS does not use alphabetical order.",
        "c": "Incorrect. BFS is deterministic, not random.",
        "d": "Incorrect. BFS does not prioritize by degree."
      },
      "correctAnswer": "a",
      "difficulty": "intermediate"
    },
    {
      "question": "During BFS, a node D is discovered via two paths: A→B→D and A→C→D. Which path does BFS record?",
      "answers": {
        "a": "The first path discovered, A→B→D.",
        "b": "The shortest path by node count.",
        "c": "Both paths simultaneously.",
        "d": "The longest path to D."
      },
      "explanations": {
        "a": "Correct. BFS records the first path to a node discovered at its level.",
        "b": "Partially correct. In BFS all nodes at the same level are equal, first discovered is used.",
        "c": "Incorrect. BFS does not store multiple paths unless specifically programmed.",
        "d": "Incorrect. BFS favors shortest path by level, not longest."
      },
      "correctAnswer": "a",
      "difficulty": "intermediate"
    },
    {
      "question": "If BFS is applied to a graph with cycles, how does the algorithm avoid infinite loops?",
      "answers": {
        "a": "By randomly skipping nodes.",
        "b": "By using the closed list to track visited nodes.",
        "c": "By limiting the depth of traversal.",
        "d": "By using a stack instead of a queue."
      },
      "explanations": {
        "a": "Incorrect. Random skipping is not part of BFS.",
        "b": "Correct. Closed list prevents revisiting nodes and loops.",
        "c": "Incorrect. Depth limit is optional, not standard.",
        "d": "Incorrect. Stack is for DFS, not BFS."
      },
      "correctAnswer": "b",
      "difficulty": "intermediate"
    },
    {
      "question": "BFS is applied to find the shortest path from node S to node G in an unweighted graph. What property ensures the path is shortest?",
      "answers": {
        "a": "Exploring all nodes at a level before moving to next level.",
        "b": "Randomly selecting nodes until goal is found.",
        "c": "Using a stack to traverse nodes.",
        "d": "Ignoring previously visited nodes."
      },
      "explanations": {
        "a": "Correct. Level-wise exploration guarantees the shortest path in unweighted graphs.",
        "b": "Incorrect. Random selection may not find shortest path.",
        "c": "Incorrect. Stack is used in DFS.",
        "d": "Incorrect. Ignoring nodes alone does not ensure shortest path."
      },
      "correctAnswer": "a",
      "difficulty": "intermediate"
    },
    {
      "question": "In BFS, what happens when a goal node is discovered in the open list?",
      "answers": {
        "a": "BFS continues exploring all nodes at that level before terminating.",
        "b": "BFS terminates immediately after removing the goal from open list.",
        "c": "BFS ignores the goal and continues.",
        "d": "BFS backtracks to the start node."
      },
      "explanations": {
        "a": "Correct. BFS completes all nodes at the same level to ensure shortest path is found.",
        "b": "Incorrect. BFS may continue if multiple nodes at same level exist.",
        "c": "Incorrect. BFS always processes goal nodes.",
        "d": "Incorrect. Backtracking is not part of BFS."
      },
      "correctAnswer": "a",
      "difficulty": "intermediate"
    }
  ]
}
